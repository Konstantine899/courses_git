# 4. Команда git checkout (часть 1)

![](img/031.png)

![](img/032.png)

Сейчас на скрене мы находимся на последней (текущей) версии нашего проекта. И допустим мы хотим посмотреть как выглядел проект в каком-то снимке в прошлом т.е. мы хотим временно сдвинуть наш указатель **HEAD** на какой-то коммит в прошлом.

![](img/033.png)

Например я хочу переместиться к коммиту №1. Синтаксис вызова смотри на слайде. И вот что произойдет после выполнения команды.

![](img/034.png)

В этом состоянии мы не можем производить какие-то изменения. Все изменения которые мы произведем и все коммиты которые мы сделаем когда наш указатель HEAD находится в состоянии **detached**(отдельный). Короче если мы не вернемся в последний актуальный коммит, все внесенные нами коммиты будут удалены.

![](img/035.png)

Для перехода к актуальному коммиту можно сделать команды **git checkuot master**.

![](img/036.png)

Практика.

Т.к. с данным репозиторием лучше не работать создаю левый репозиторий где на каждом коммите буду добавлять файл.

![](img/037.png)

Создал 10 коммитов в которые помещал по одному файлу. Теперь перехожу к первому коммиту.

![](img/038.png)

В Note он говорит что мы перешли к указанному коммиту и теперь наш указатель HEADнаходится в состоянии **dateched**. В данном сообщении так же написано что можно смотреть на данный проект, можно эксперементировать, смотреть как выглядел проект во время этого коммита, но все коммиты, все изменения которые будут сделаны в состоянии **detached** они будут удалены.

Здесь так же написано что если вы ходите в этом состоянии делать какие-то коммиты, если вы хотите вносить какие-то изменения, то вы должны создать отдельную ветку для этого.

И так же написано что наш указатель **HEAD** сейчас находится на этом коммите. Если мы посмотрим на историю коммитов то мы увидим что **GIT** думает что у нас всего один коммит.

![](img/039.png)

Возвращаюсь к текущей версии проекта **git checkout master**. И если снова посмотреть на историю комиитов **git log** у нас снова **GIT** видит 10-ть коммитов. Все файлы которые были закомичены подтянулись.

![](img/040.png)

Данная команда **git checkout** позволяет нам перемещаться между версиями файлов.

![](img/041.png)

Допустим мы хоти вернуть какой-то конкретный файл(лы) в какой-то версиив прошлом. Здесь есть небольшое отличие от команды которая используется для перемещения меджу коммитами. Когда мы перемещаемся между коммитами мы ничего не изменяем, мы просто наш указатель **HEAD** сдвигаем к другому коммиту и просто смотрим на состояние нашего репозитория в каком-то снимке в прошлом. При этом мы ничего в текущем состоянии репозитория т.е. в последнем коммите мы ничего не изменяем.

Здесь же мы можем в текущем репозитория поменять состояние некоторых файлов.

![](img/042.png)

Т.е. эта версия команды **git checkout** может реально поменять какие-то файлы в нашем текущем коммите.

![](img/043.png)

Так же есть версия этого вызова без версии коммита.

![](img/044.png)

Допустим у нас есть некое число коммитов, дольше ни каких изменений в проекте нет. Затем мы берем какой-нибудь файл и там что-то меняем, мы понимаем что совершили ошибку и мы хотим вернуть состояние этого файла к последнему коммиту и мы можем сделать **git checkout -- путь*до*файла*1 путь*до_файла_3 ...** Эта команда откатит файл к последнему актуальному коммиту т.е. к **HEAD**.

Помимо этого мы можем вызвать данную команду просто с точкой git **checkout -- .** Эта команда вернет все файлы в репозитории к версии которая у них была в последнем коммите.

![](img/045.png)

Что же если я хочу удалить отслеживаемые изменения?

![](img/046.png)

Т.е. после коммита я совершил какието изменения, далее я их перевел в отслеживаемую зону т.е. сделал git add. Но я хочу удалить эти изменения. Вспоминаю урок про **git reset**. Отслеживаемые изменения перевожу в не отслеживаемые с помощью **git reset**. И после с помощью **git checkout -- .** удаляю все не отслеживаемые изменения.

Так же возникает вопрос зачем использовать две черты? Ведь можно и без них.

![](img/047.png)

Две черты указывают что после них идет обычный текст, в нашем случае это путь до файла или файлов.

Где это бывает нужно?

![](img/048.png)

Если мы сделаем **git checkout master** то он нас не поймет и произведет переключение на ветку **master**. А если я сделаю **git checkout --master** она произведет возвращение файла с названием **master** к версии из последнего коммита.

Т.е. если мы не ставим две черточки то **GIT** после команды **git checkout** последующие команды воспринимает как ключевые слова.

![](img/049.png)

Рассмотрим удаление изменений.

![](img/050.png)

Есть не отслеживаемое изменение. Удаляю не отслеживаемые изменения. Ввожу команду две черточки и название файла **git checkout -- test001.md**

![](img/051.png)

И вот я удалил внесенные изменения. Введенный текст пропал. Мы могли указать явно **git checkout HEAD -- test001.md** тем самым указать к какому коммиту мы хотим вернуть наш файл **test001.md**.

Если мы не указываем ни какой коммит то GIT сам понимает что мы хотим вернуть файл к состоянию последнего коммита.

Выполним эту же команду с точкой. Вот у меня два измененных файла.

![](img/052.png)

![](img/053.png)

Как видим изменения были а теперь их нет.

Теперь уберем отслеживаемые изменения.

![](img/054.png)

Добавил файлы в отслеживаемые, после чего сказал что их отслеживать не нужно, после чего удалил внесенные изменения.

И рассмотрим последнее. Откат файла к предыдущим коммитам. Для этого **git checkout 0679d5f986246e74fa64892a7b0f51ddccaaf1b9 -- и указываю тот файл который хочу вернуть к версии данного коммита test001**.

![](img/055.png)
